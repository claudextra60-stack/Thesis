<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Projection of Lines & Curves - Eng Draw VR</title>
  <link rel="icon" type="image/png" href="https://i.ibb.co/v4FSdxGv/cropped-circle-image.png">
  <meta name="theme-color" content="#2B2B88">

  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.2.0/dist/aframe-extras.min.js"></script>

  <style>
    body { font-family: sans-serif; margin: 0; overflow: hidden; background: #000; }
    
    #loading {
      position: fixed; inset: 0; background: #111; z-index: 999;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      color: white; font-weight: 300; letter-spacing: 2px;
    }

    #overlay {
      position: fixed; inset: 0; z-index: 100;
      background: linear-gradient(135deg, rgba(15,15,20,0.95) 0%, rgba(30,30,60,0.92) 100%);
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      color: white; text-align: center;
    }
    h1 { font-weight: 800; font-size: 3rem; margin: 0 0 10px 0; letter-spacing: -1px; }
    p { color: #aaa; font-size: 1.1rem; max-width: 600px; line-height: 1.6; margin-bottom: 30px; }
    
    .controls-hint {
        background: rgba(255,255,255,0.1); padding: 15px 30px; border-radius: 8px;
        text-align: left; font-size: 0.9rem; color: #ddd; margin-bottom: 30px;
    }
    .controls-hint strong { color: #fff; margin-right: 10px; }

    .btn {
      padding: 16px 48px; font-size: 1rem; font-weight: 600;
      background: #2B2B88; color: white; border: none; border-radius: 6px;
      cursor: pointer; text-transform: uppercase; letter-spacing: 1px;
      transition: all 0.2s ease;
    }
    .btn:hover { background: #3d3db5; transform: translateY(-2px); box-shadow: 0 4px 15px rgba(43,43,136,0.5); }
  </style>

  <script>
    // ─── AUDIO MANAGER ──────────────────────────────────────
    const AudioManager = {
      waves: new Audio('waves.mp3'), birds: new Audio('birds.mp3'), waves2: new Audio('waves2.mp3'),
      timers: [],
      init: function () {
        this.waves.loop = true; this.waves.volume = 0.4;
        this.birds.volume = 0.6;
        this.birds.addEventListener('ended', () => this.scheduleNextBird());
        this.waves2.volume = 0; this.waves2.loop = true;
      },
      start: function () { this.waves.play().catch(()=>{}); this.scheduleNextBird(); this.scheduleWaves2(); },
      stop: function () { this.waves.pause(); this.birds.pause(); this.waves2.pause(); this.timers.forEach(t=>clearTimeout(t)); this.timers=[]; },
      scheduleNextBird: function () {
        this.timers.push(setTimeout(() => { this.birds.currentTime=0; this.birds.play().catch(()=>{}); }, Math.random()*17000+8000));
      },
      scheduleWaves2: function () {
        this.timers.push(setTimeout(() => this.playWaves2Swell(), Math.random()*20000+10000));
      },
      playWaves2Swell: function () {
        this.waves2.currentTime=0; this.waves2.play().catch(()=>{});
        const tv=Math.random()*0.5+0.3, dur=Math.random()*10000+8000, fi=Math.random()*3000+2000, fo=Math.random()*3000+2000;
        this.fadeAudio(this.waves2, 0, tv, fi, () => {
          this.timers.push(setTimeout(() => { this.fadeAudio(this.waves2, tv, 0, fo, () => { this.waves2.pause(); this.scheduleWaves2(); }); }, dur));
        });
      },
      fadeAudio: function (audio, s, e, dur, cb) {
        const steps=60, st=dur/steps, vs=(e-s)/steps; let c=0;
        const iv=setInterval(() => { c++; audio.volume=Math.max(0,Math.min(1,s+vs*c)); if(c>=steps){clearInterval(iv);if(cb)cb();} }, st);
        this.timers.push(iv);
      }
    };
    AudioManager.init();

    // ─── COMPONENT: DRAW THICK 3D LINE ──────────────────────
    AFRAME.registerComponent('draw-line', {
      schema: {
        start: {type: 'vec3', default: {x:0, y:0, z:0}},
        end:   {type: 'vec3', default: {x:1, y:1, z:1}},
        color: {type: 'color', default: '#000'},
        radius:{type: 'number', default: 0.012}
      },
      init: function () { this.update(); },
      update: function () {
        const d = this.data;
        const p1 = new THREE.Vector3(d.start.x, d.start.y, d.start.z);
        const p2 = new THREE.Vector3(d.end.x, d.end.y, d.end.z);
        const distance = p1.distanceTo(p2);
        
        if(distance < 0.001) return; 

        const midPoint = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);

        this.el.setAttribute('geometry', `primitive: cylinder; radius: ${d.radius}; height: ${distance}; segmentsRadial: 6`);
        this.el.setAttribute('material', `color: ${d.color}; shader: flat`);
        this.el.object3D.position.copy(midPoint);
        
        const direction = new THREE.Vector3().subVectors(p2, p1).normalize();
        this.el.object3D.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
      }
    });

    // ─── BIRD FLIGHT ────────────────────────────────────────
    AFRAME.registerComponent('bird-flight', {
      schema: { speed: { default: 4 }, radius: { default: 25 }, heightRange: { type: 'vec2', default: {x: 10, y: 20} } },
      init: function () {
        const angle = Math.random() * Math.PI * 2, dist = Math.random() * this.data.radius;
        this.el.object3D.position.set(Math.cos(angle) * dist, this.data.heightRange.x + Math.random() * (this.data.heightRange.y - this.data.heightRange.x), Math.sin(angle) * dist);
        this.el.object3D.rotation.y = Math.random() * Math.PI * 2;
        this.turnSpeed = 0; this.targetTurnSpeed = (Math.random() - 0.5) * 0.02;
      },
      tick: function (time, timeDelta) {
        if (!timeDelta) return;
        this.el.object3D.translateZ(this.data.speed * (timeDelta / 1000));
        const pos = this.el.object3D.position, dist = Math.sqrt(pos.x * pos.x + pos.z * pos.z);
        if (dist > this.data.radius) this.turnSpeed = 0.015;
        else { if (Math.random() < 0.01) this.targetTurnSpeed = (Math.random() - 0.5) * 0.02; this.turnSpeed += (this.targetTurnSpeed - this.turnSpeed) * 0.1; }
        this.el.object3D.rotation.y += this.turnSpeed; this.el.object3D.rotation.z = -this.turnSpeed * 30; this.el.object3D.position.y += Math.sin(time / 500) * 0.005;
      }
    });

    // ─── INTERACTION ────────────────────────────────────────
    AFRAME.registerComponent('ortho-interaction', {
      init: function () {
        this.el.addEventListener('triggerdown', (e) => {
            const raycaster = this.el.components.raycaster;
            if (!raycaster) return;
            const hits = raycaster.intersectedEls;
            for (let i = 0; i < hits.length; i++) {
                if (hits[i].classList.contains('interactive')) {
                    hits[i].emit('click');
                    if (this.el.components.haptics) this.el.components.haptics.pulse(0.5, 50);
                    break; 
                }
            }
        });
      }
    });
  </script>
</head>

<body>
  <div id="loading">LOADING MODULE...</div>

  <div id="overlay">
    <h1>PROJECTIONS & CURVES</h1>
    <p>Master the geometry of lines, polygons, and 3D curves on solid projection planes.</p>
    <div class="controls-hint">
        <div><strong>RIGHT TRIGGER (Click):</strong> Press Menu Buttons</div>
        <div><strong>UNFOLD 2D:</strong> Swings the Horizontal Plane down to read the textbook drawing.</div>
    </div>
    <button class="btn" id="start-btn">ENTER LAB</button>
  </div>

  <a-scene id="vr-scene" cursor="rayOrigin: mouse" raycaster="objects: .interactive">

    <a-assets>
      <img id="sky-panorama" src="https://dl.polyhaven.org/file/ph-assets/HDRIs/extra/Tonemapped%20JPG/secluded_beach.jpg" crossorigin="anonymous">
      <img id="sand-tex"     src="https://cdn.architextures.org/textures/24/5/sand-j9sy8a.jpg" crossorigin="anonymous">
      <img id="soil-tex"     src="https://cdn.architextures.org/textures/23/5/soil-none-5i4x9p.jpg" crossorigin="anonymous">
      <img id="jute-tex"     src="https://cdn.architextures.org/textures/21/07/hyacinth-weave-60e33404a3929-1200.jpg?s=400&q=60" crossorigin="anonymous">
      <img id="sisal-tex"    src="https://cdn.architextures.org/textures/21/07/sisal-weave-60e333df44d3b-1200.jpg" crossorigin="anonymous">

      <a-asset-item id="parrot-model"   src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r129/examples/models/gltf/Parrot.glb"></a-asset-item>
      <a-asset-item id="flamingo-model" src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r129/examples/models/gltf/Flamingo.glb"></a-asset-item>
    </a-assets>

    <a-sky src="#sky-panorama" rotation="0 -90 0"></a-sky>
    <a-entity id="environment-group">
        <a-plane position="0 0 0" rotation="-90 0 0" width="20" height="20" src="#sand-tex" repeat="8 8"></a-plane>
        <a-ring position="0 0.01 0" rotation="-90 0 0" radius-inner="10" radius-outer="25" src="#soil-tex" repeat="3 8"></a-ring>
    </a-entity>
    
    <a-entity id="birds">
      <a-entity gltf-model="#parrot-model" scale="0.02 0.02 0.02" animation-mixer="clip: *; timeScale: 1.2" bird-flight="speed: 5.5; radius: 30; heightRange: 8 15"></a-entity>
      <a-entity gltf-model="#flamingo-model" scale="0.03 0.03 0.03" animation-mixer="clip: *; timeScale: 0.8" bird-flight="speed: 3.5; radius: 40; heightRange: 15 25"></a-entity>
    </a-entity>

    <a-entity light="type: ambient; intensity: 0.9; color: #FFF8DC"></a-entity>
    <a-entity light="type: directional; position: 3 8 3; intensity: 1.0;"></a-entity>

    <a-entity id="projection-apparatus" position="0 1.0 -1.8">
        
        <a-entity position="0 0 0">
            <a-cylinder position="0 0 0" radius="0.012" height="2.0" rotation="0 0 90" color="#CF2027"></a-cylinder>
            <a-text value="X" position="-1.1 0 0" align="center" color="#CF2027" font="roboto"></a-text>
            <a-text value="Y" position="1.1 0 0" align="center" color="#CF2027" font="roboto"></a-text>
        </a-entity>

        <a-entity position="0 0.6 0">
            <a-plane width="2.0" height="1.2" color="#2A5298" side="double" material="depthWrite: true"></a-plane>
            <a-entity line="start: -1 0.6 0.005; end: 1 0.6 0.005; color: #FFF"></a-entity>
            <a-entity line="start: -1 -0.6 0.005; end: -1 0.6 0.005; color: #FFF"></a-entity>
            <a-entity line="start: 1 -0.6 0.005; end: 1 0.6 0.005; color: #FFF"></a-entity>
            <a-text value="VP" position="0.85 0.5 0.01" color="#FFF" width="4" font="roboto"></a-text>
        </a-entity>

        <a-entity id="vp-drawings"></a-entity>

        <a-entity id="hp-hinge">
            <a-entity position="0 0 0.6">
                <a-plane id="hp-surface" width="2.0" height="1.2" rotation="-90 0 0" color="#1E6B3A" side="double" material="depthWrite: true"></a-plane>
                <a-entity line="start: -1 0.005 0.6; end: 1 0.005 0.6; color: #FFF"></a-entity>
                <a-entity line="start: -1 0.005 -0.6; end: -1 0.005 0.6; color: #FFF"></a-entity>
                <a-entity line="start: 1 0.005 -0.6; end: 1 0.005 0.6; color: #FFF"></a-entity>
                <a-text value="HP" position="0.85 0.01 0.5" rotation="-90 0 0" color="#FFF" width="4" font="roboto"></a-text>
            </a-entity>
            
            <a-entity id="hp-drawings" position="0 0.005 0"></a-entity>
        </a-entity>

        <a-entity id="elements-3d"></a-entity>
    </a-entity>

    <a-entity id="exercise-ui" position="-2.2 1.4 -0.8" rotation="0 45 0">
        <a-box width="1.8" height="1.2" depth="0.05" src="#jute-tex" repeat="1 1" color="#BBB">
            <a-plane width="1.75" height="1.15" position="0 0 0.026" color="#111" opacity="0.9"></a-plane>
            <a-text value="PROJECTION LAB" position="0 0.45 0.05" align="center" width="2.2" font="roboto" color="#FFF" letter-spacing="1"></a-text>
            <a-plane width="1.6" height="0.002" position="0 0.4 0.05" color="#2B2B88"></a-plane>
            <a-text id="desc-text" value="Loading..." position="0 0.2 0.05" align="center" width="1.8" font="roboto" color="#AAA"></a-text>

            <a-plane class="interactive" id="btn-unfold" position="0 0.0 0.05" width="0.8" height="0.15" color="#2B2B88">
                <a-text id="unfold-label" value="UNFOLD 2D" align="center" width="2" position="0 0 0.01"></a-text>
            </a-plane>

            <a-plane class="interactive" id="btn-prev" position="-0.5 -0.25 0.05" width="0.4" height="0.12" color="#333">
                <a-text value="< PREV" align="center" width="1.5" position="0 0 0.01"></a-text>
            </a-plane>
            <a-plane class="interactive" id="btn-next" position="0.5 -0.25 0.05" width="0.4" height="0.12" color="#333">
                <a-text value="NEXT >" align="center" width="1.5" position="0 0 0.01"></a-text>
            </a-plane>

            <a-text id="level-indicator" value="LEVEL 1 / 30" position="0 -0.45 0.05" align="center" width="2" color="#888"></a-text>
        </a-box>
    </a-entity>

    <a-entity id="exit-door" position="0 1.6 4" rotation="0 180 0">
        <a-plane class="interactive" id="btn-home" width="1.5" height="0.6" src="#sisal-tex" repeat="1 1" color="#999">
             <a-box width="1.6" height="0.7" depth="0.1" position="0 0 -0.06" color="#333"></a-box>
             <a-text value="EXIT TO MAIN MENU" align="center" width="3" position="0 0 0.02" color="#000" font="roboto"></a-text>
        </a-plane>
    </a-entity>

    <a-entity id="rig" movement-controls="speed: 0.15">
      <a-entity id="camera" camera position="0 1.5 0.5" look-controls></a-entity>
      <a-entity id="left-controller" oculus-touch-controls="hand: left" vr-controller-module="hand: left" raycaster="objects: .interactive; far: 5; showLine: true; lineColor: cyan"></a-entity>
      <a-entity id="right-controller" oculus-touch-controls="hand: right" ortho-interaction raycaster="objects: .interactive; far: 5; showLine: true; lineColor: red"></a-entity>
    </a-entity>
  </a-scene>

  <script>
    // ─── GEOMETRY GENERATORS ───
    function makeLine(ax,ay,az, bx,by,bz, lblA="A", lblB="B") {
        return { type: 'line', p1: [ax,ay,az], p2: [bx,by,bz], labelA: lblA, labelB: lblB };
    }
    
    function makePoly(pts, closed=false, dropProjectors=[]) {
        if(closed) pts.push(pts[0]);
        // If no specific projectors defined, project vertices
        if(dropProjectors.length === 0) dropProjectors = pts.map((_, i) => i);
        return { type: 'polyline', pts: pts, projectors: dropProjectors };
    }

    function makeCurve(cx, cy, cz, radius, startAngle, endAngle, axis, tiltAxis='', tiltAngle=0, segments=24) {
        const pts = [];
        for(let i=0; i<=segments; i++) {
            let t = i/segments;
            let angle = startAngle + t * (endAngle - startAngle);
            let px = 0, py = 0, pz = 0;
            if(axis === 'Z') { px = Math.cos(angle)*radius; py = Math.sin(angle)*radius; pz = 0; }
            if(axis === 'Y') { px = Math.cos(angle)*radius; pz = Math.sin(angle)*radius; py = 0; }
            if(axis === 'X') { py = Math.cos(angle)*radius; pz = Math.sin(angle)*radius; px = 0; }

            let rpx = px, rpy = py, rpz = pz;
            if(tiltAngle !== 0) {
               let rad = tiltAngle * Math.PI/180;
               if(tiltAxis === 'X') { rpy = py*Math.cos(rad) - pz*Math.sin(rad); rpz = py*Math.sin(rad) + pz*Math.cos(rad); } 
               else if(tiltAxis === 'Y') { rpx = px*Math.cos(rad) + pz*Math.sin(rad); rpz = -px*Math.sin(rad) + pz*Math.cos(rad); }
               else if(tiltAxis === 'Z') { rpx = px*Math.cos(rad) - py*Math.sin(rad); rpy = px*Math.sin(rad) + py*Math.cos(rad); }
            }
            pts.push([cx + rpx, cy + rpy, cz + rpz]);
        }
        // Project start, middle, and end of the curve
        return { type: 'polyline', pts: pts, projectors: [0, Math.floor(segments/2), segments] };
    }

    function makeHelix(cx, cy, cz, radius, height, turns, segments=40) {
        const pts = [];
        for(let i=0; i<=segments; i++) {
            let t = i/segments;
            let angle = t * Math.PI * 2 * turns;
            pts.push([ cx + Math.cos(angle)*radius, cy + t*height, cz + Math.sin(angle)*radius ]);
        }
        return { type: 'polyline', pts: pts, projectors: [0, segments] };
    }

    // ─── 30 LEVELS OF PROGRESSION ───
    const levels = [
        // PHASE 1: Basics (1-6)
        { desc: "1. Line parallel to both HP and VP.", shapes: [ makeLine(-0.4,0.5,0.5, 0.4,0.5,0.5) ] },
        { desc: "2. Line perpendicular to VP, parallel to HP.", shapes: [ makeLine(0,0.5,0.2, 0,0.5,0.8) ] },
        { desc: "3. Line perpendicular to HP, parallel to VP.", shapes: [ makeLine(0,0.2,0.5, 0,0.8,0.5) ] },
        { desc: "4. Line resting exactly ON the Horizontal Plane.", shapes: [ makeLine(-0.4,0.0,0.5, 0.4,0.0,0.5) ] },
        { desc: "5. Line resting exactly ON the Vertical Plane.", shapes: [ makeLine(-0.4,0.5,0.0, 0.4,0.5,0.0) ] },
        { desc: "6. Line resting exactly ON the XY line.", shapes: [ makeLine(-0.4,0.0,0.0, 0.4,0.0,0.0) ] },
        
        // PHASE 2: Single Inclination (7-12)
        { desc: "7. Line inclined to HP. Notice Top View shrinks.", shapes: [ makeLine(-0.3,0.2,0.5, 0.3,0.8,0.5) ] },
        { desc: "8. Steeper incline to HP. Top View shrinks further.", shapes: [ makeLine(-0.2,0.1,0.5, 0.2,0.9,0.5) ] },
        { desc: "9. Line inclined to VP. Notice Front View shrinks.", shapes: [ makeLine(-0.3,0.5,0.2, 0.3,0.5,0.8) ] },
        { desc: "10. Steeper incline to VP. Front View shrinks further.", shapes: [ makeLine(-0.2,0.5,0.1, 0.2,0.5,0.9) ] },
        { desc: "11. Inclined to HP, Point A rests on HP.", shapes: [ makeLine(-0.3,0.0,0.5, 0.3,0.8,0.5) ] },
        { desc: "12. Inclined to VP, Point A rests on VP.", shapes: [ makeLine(-0.3,0.5,0.0, 0.3,0.5,0.8) ] },

        // PHASE 3: Double Inclination (13-16)
        { desc: "13. Double Inclination: Inclined to both HP & VP.", shapes: [ makeLine(-0.3,0.2,0.2, 0.3,0.5,0.6) ] },
        { desc: "14. Steep Double Inclination. Projections are very short.", shapes: [ makeLine(-0.2,0.1,0.1, 0.2,0.8,0.8) ] },
        { desc: "15. Inclined to both. A on HP, B on VP.", shapes: [ makeLine(-0.3,0.0,0.6, 0.3,0.6,0.0) ] },
        { desc: "16. Extreme double inclination.", shapes: [ makeLine(-0.4,0.1,0.8, 0.4,0.9,0.1) ] },

        // PHASE 4: Polygons (17-23)
        { desc: "17. Connected Lines (V-Shape).", shapes: [ makePoly([[-0.3,0.6,0.5], [0,0.2,0.5], [0.3,0.6,0.5]]) ] },
        { desc: "18. Triangle parallel to VP.", shapes: [ makePoly([[-0.3,0.3,0.5], [0,0.8,0.5], [0.3,0.3,0.5]], true) ] },
        { desc: "19. Triangle inclined to VP. (Becomes narrower).", shapes: [ makePoly([[-0.3,0.3,0.2], [0,0.8,0.5], [0.3,0.3,0.8]], true) ] },
        { desc: "20. Square resting parallel to HP.", shapes: [ makePoly([[-0.3,0.4,0.3], [0.3,0.4,0.3], [0.3,0.4,0.8], [-0.3,0.4,0.8]], true) ] },
        { desc: "21. Square inclined to HP. (Front view is a line).", shapes: [ makePoly([[-0.3,0.2,0.3], [0.3,0.2,0.3], [0.3,0.6,0.8], [-0.3,0.6,0.8]], true) ] },
        { desc: "22. Hexagon parallel to VP.", shapes: [ makeCurve(0,0.5,0.5, 0.3, 0, Math.PI*2, 'Z', '', 0, 6) ] },
        { desc: "23. Hexagon inclined to VP.", shapes: [ makeCurve(0,0.5,0.5, 0.3, 0, Math.PI*2, 'Z', 'Y', 45, 6) ] },

        // PHASE 5: Complex Curves & 3D Objects (24-30)
        { desc: "24. Semicircle parallel to VP.", shapes: [ makeCurve(0,0.4,0.5, 0.3, 0, Math.PI, 'Z') ] },
        { desc: "25. Semicircle inclined to HP (Projects as Ellipse).", shapes: [ makeCurve(0,0.4,0.5, 0.3, 0, Math.PI, 'Z', 'X', 45) ] },
        { desc: "26. Full Circle parallel to HP.", shapes: [ makeCurve(0,0.5,0.5, 0.3, 0, Math.PI*2, 'Y', '', 0, 32) ] },
        { desc: "27. Full Circle inclined to VP (Projects as Ellipse).", shapes: [ makeCurve(0,0.5,0.5, 0.3, 0, Math.PI*2, 'Y', 'X', 45, 32) ] },
        { desc: "28. S-Curve (Math Sine Wave).", shapes: [ 
            makeCurve(-0.2,0.5,0.5, 0.2, Math.PI, Math.PI*2, 'Z', '', 0, 16),
            makeCurve(0.2,0.5,0.5, 0.2, 0, Math.PI, 'Z', '', 0, 16)
        ]},
        { desc: "29. 3D Helix / Spring.", shapes: [ makeHelix(0, 0.2, 0.5, 0.2, 0.6, 3) ] },
        { desc: "30. 3D Wireframe Assembly (House).", shapes: [ 
            makePoly([[-0.2,0.2,0.3], [0.2,0.2,0.3], [0.2,0.2,0.7], [-0.2,0.2,0.7]], true, [0,1,2,3]), // Base
            makePoly([[-0.2,0.6,0.3], [0.2,0.6,0.3], [0.2,0.6,0.7], [-0.2,0.6,0.7]], true, []),      // Ceiling
            makeLine(-0.2,0.2,0.3, -0.2,0.6,0.3,"",""), makeLine(0.2,0.2,0.3, 0.2,0.6,0.3,"",""),  // Pillars
            makeLine(0.2,0.2,0.7, 0.2,0.6,0.7,"",""), makeLine(-0.2,0.2,0.7, -0.2,0.6,0.7,"",""),
            makePoly([[-0.2,0.6,0.3], [0,0.9,0.5], [0.2,0.6,0.3]], false, [1]), // Front Roof
            makePoly([[-0.2,0.6,0.7], [0,0.9,0.5], [0.2,0.6,0.7]], false, [])   // Back Roof
        ]}
    ];

    let currentLevel = 0;
    let isUnfolded = false;

    const elElements3D = document.getElementById('elements-3d');
    const elVpDrawings = document.getElementById('vp-drawings');
    const elHpDrawings = document.getElementById('hp-drawings');
    const txtLevel = document.getElementById('level-indicator');
    const txtDesc = document.getElementById('desc-text');
    const btnUnfold = document.getElementById('btn-unfold');
    const labelUnfold = document.getElementById('unfold-label');
    const hpPlane = document.getElementById('hp-hinge');

    function createHTMLNode(tag, attributes) {
        const el = document.createElement(tag);
        for(let key in attributes) el.setAttribute(key, attributes[key]);
        return el;
    }

    function renderLevel(idx) {
        if (isUnfolded) toggleFold();

        elElements3D.innerHTML = '';
        elVpDrawings.innerHTML = '';
        elHpDrawings.innerHTML = '';

        const data = levels[idx];
        txtLevel.setAttribute('value', `LEVEL ${idx + 1} / 30`);
        txtDesc.setAttribute('value', data.desc);

        // Styling Configs
        const color3D = '#FF7B00'; // Bright Orange for the floating physical object
        const colorChalk = '#FFFFFF'; // White for chalk lines
        const colorProj = '#AAAAAA'; // Grey for projectors

        data.shapes.forEach(shape => {
            if(shape.type === 'line') {
                const [ax, ay, az] = shape.p1;
                const [bx, by, bz] = shape.p2;

                // 3D Object
                elElements3D.appendChild(createHTMLNode('a-entity', { 'draw-line': `start: ${ax} ${ay} ${az}; end: ${bx} ${by} ${bz}; color: ${color3D}` }));
                if(shape.labelA) {
                    elElements3D.appendChild(createHTMLNode('a-sphere', { position: `${ax} ${ay} ${az}`, radius: '0.02', color: color3D }));
                    elElements3D.appendChild(createHTMLNode('a-text', { value: shape.labelA, position: `${ax+0.05} ${ay+0.05} ${az}`, color: color3D, align: 'center', scale: '0.5 0.5 0.5' }));
                }
                if(shape.labelB) {
                    elElements3D.appendChild(createHTMLNode('a-sphere', { position: `${bx} ${by} ${bz}`, radius: '0.02', color: color3D }));
                    elElements3D.appendChild(createHTMLNode('a-text', { value: shape.labelB, position: `${bx+0.05} ${by+0.05} ${bz}`, color: color3D, align: 'center', scale: '0.5 0.5 0.5' }));
                }

                // Projectors
                elElements3D.appendChild(createHTMLNode('a-entity', { line: `start: ${ax} ${ay} ${az}; end: ${ax} ${ay} 0; color: ${colorProj}; opacity: 0.5` }));
                elElements3D.appendChild(createHTMLNode('a-entity', { line: `start: ${bx} ${by} ${bz}; end: ${bx} ${by} 0; color: ${colorProj}; opacity: 0.5` }));
                elElements3D.appendChild(createHTMLNode('a-entity', { line: `start: ${ax} ${ay} ${az}; end: ${ax} 0 ${az}; color: ${colorProj}; opacity: 0.5` }));
                elElements3D.appendChild(createHTMLNode('a-entity', { line: `start: ${bx} ${by} ${bz}; end: ${bx} 0 ${bz}; color: ${colorProj}; opacity: 0.5` }));

                // VP Projection (Z=0.01 slightly offset from solid board)
                elVpDrawings.appendChild(createHTMLNode('a-entity', { 'draw-line': `start: ${ax} ${ay} 0.01; end: ${bx} ${by} 0.01; color: ${colorChalk}; radius: 0.008` }));
                if(shape.labelA) elVpDrawings.appendChild(createHTMLNode('a-circle', { position: `${ax} ${ay} 0.015`, radius: '0.015', color: colorChalk }));
                if(shape.labelB) elVpDrawings.appendChild(createHTMLNode('a-circle', { position: `${bx} ${by} 0.015`, radius: '0.015', color: colorChalk }));

                // HP Projection (Y=0.01 slightly offset from solid board)
                elHpDrawings.appendChild(createHTMLNode('a-entity', { 'draw-line': `start: ${ax} 0.01 ${az}; end: ${bx} 0.01 ${bz}; color: ${colorChalk}; radius: 0.008` }));
                if(shape.labelA) elHpDrawings.appendChild(createHTMLNode('a-circle', { position: `${ax} 0.015 ${az}`, rotation: '-90 0 0', radius: '0.015', color: colorChalk }));
                if(shape.labelB) elHpDrawings.appendChild(createHTMLNode('a-circle', { position: `${bx} 0.015 ${bz}`, rotation: '-90 0 0', radius: '0.015', color: colorChalk }));
            }
            
            if(shape.type === 'polyline') {
                const pts = shape.pts;
                for(let i=0; i<pts.length-1; i++) {
                    const [ax, ay, az] = pts[i];
                    const [bx, by, bz] = pts[i+1];

                    // 3D Segments
                    elElements3D.appendChild(createHTMLNode('a-entity', { 'draw-line': `start: ${ax} ${ay} ${az}; end: ${bx} ${by} ${bz}; color: ${color3D}` }));
                    // VP Chalk Line
                    elVpDrawings.appendChild(createHTMLNode('a-entity', { 'draw-line': `start: ${ax} ${ay} 0.01; end: ${bx} ${by} 0.01; color: ${colorChalk}; radius: 0.006` }));
                    // HP Chalk Line
                    elHpDrawings.appendChild(createHTMLNode('a-entity', { 'draw-line': `start: ${ax} 0.01 ${az}; end: ${bx} 0.01 ${bz}; color: ${colorChalk}; radius: 0.006` }));
                }

                // Selective Projectors (so we don't draw 100 drop lines for curves)
                if(shape.projectors) {
                    shape.projectors.forEach(idx => {
                        if(idx < pts.length) {
                            const [px, py, pz] = pts[idx];
                            elElements3D.appendChild(createHTMLNode('a-entity', { line: `start: ${px} ${py} ${pz}; end: ${px} ${py} 0; color: ${colorProj}; opacity: 0.4` }));
                            elElements3D.appendChild(createHTMLNode('a-entity', { line: `start: ${px} ${py} ${pz}; end: ${px} 0 ${pz}; color: ${colorProj}; opacity: 0.4` }));
                        }
                    });
                }
            }
        });
    }

    function toggleFold() {
        const hpSurface = document.getElementById('hp-surface');
        
        if(isUnfolded) {
            // Unfolding back to 3D: Rotate up, fade back to green
            hpPlane.setAttribute('animation', 'property: rotation; to: 0 0 0; dur: 1000; easing: easeInOutQuad');
            hpSurface.setAttribute('animation__color', 'property: material.color; type: color; to: #1E6B3A; dur: 1000');
            elElements3D.setAttribute('animation', 'property: scale; to: 1 1 1; dur: 800');
            labelUnfold.setAttribute('value', 'UNFOLD 2D');
            btnUnfold.setAttribute('color', '#2B2B88');
            isUnfolded = false;
        } else {
            // Folding to 2D: Rotate down, fade to blue to match VP
            hpPlane.setAttribute('animation', 'property: rotation; to: -90 0 0; dur: 1000; easing: easeInOutQuad');
            hpSurface.setAttribute('animation__color', 'property: material.color; type: color; to: #2A5298; dur: 1000');
            elElements3D.setAttribute('animation', 'property: scale; to: 0 0 0; dur: 500'); 
            labelUnfold.setAttribute('value', 'FOLD TO 3D');
            btnUnfold.setAttribute('color', '#CF2027');
            isUnfolded = true;
        }
    }

    function loadLevel(idx) {
        if (idx < 0) idx = 0;
        if (idx >= levels.length) idx = levels.length - 1;
        currentLevel = idx;
        renderLevel(currentLevel);
    }

    document.getElementById('start-btn').addEventListener('click', () => {
      document.getElementById('overlay').style.display = 'none';
      if(AudioManager && AudioManager.start) AudioManager.start();
      loadLevel(0);
    });

    document.getElementById('btn-home').addEventListener('click', () => { window.location.href = 'index.html'; });
    document.getElementById('btn-next').addEventListener('click', () => loadLevel(currentLevel + 1));
    document.getElementById('btn-prev').addEventListener('click', () => loadLevel(currentLevel - 1));
    btnUnfold.addEventListener('click', toggleFold);

    // Initial Hide Loading
    const scene = document.querySelector('a-scene');
    if (scene.hasLoaded) {
        document.getElementById('loading').style.display = 'none';
    } else {
        scene.addEventListener('loaded', () => { document.getElementById('loading').style.display = 'none'; });
    }

  </script>
</body>
</html>